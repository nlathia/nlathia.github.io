<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>When is a neural net too big for production? | Neal Lathia</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="When is a neural net too big for production?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Here are some thoughts on the recent discussions around NLP transformer models being too big to put into production, and a dive into how we have shipped them at Monzo using the HuggingFace library." />
<meta property="og:description" content="Here are some thoughts on the recent discussions around NLP transformer models being too big to put into production, and a dive into how we have shipped them at Monzo using the HuggingFace library." />
<link rel="canonical" href="http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html" />
<meta property="og:url" content="http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html" />
<meta property="og:site_name" content="Neal Lathia" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-09-29T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"Here are some thoughts on the recent discussions around NLP transformer models being too big to put into production, and a dive into how we have shipped them at Monzo using the HuggingFace library.","headline":"When is a neural net too big for production?","dateModified":"2019-09-29T00:00:00-05:00","datePublished":"2019-09-29T00:00:00-05:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html"},"url":"http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="Neal Lathia" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>When is a neural net too big for production? | Neal Lathia</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="When is a neural net too big for production?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Here are some thoughts on the recent discussions around NLP transformer models being too big to put into production, and a dive into how we have shipped them at Monzo using the HuggingFace library." />
<meta property="og:description" content="Here are some thoughts on the recent discussions around NLP transformer models being too big to put into production, and a dive into how we have shipped them at Monzo using the HuggingFace library." />
<link rel="canonical" href="http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html" />
<meta property="og:url" content="http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html" />
<meta property="og:site_name" content="Neal Lathia" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-09-29T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"Here are some thoughts on the recent discussions around NLP transformer models being too big to put into production, and a dive into how we have shipped them at Monzo using the HuggingFace library.","headline":"When is a neural net too big for production?","dateModified":"2019-09-29T00:00:00-05:00","datePublished":"2019-09-29T00:00:00-05:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html"},"url":"http://0.0.0.0:4000/opinion/monzo/2019/09/29/Large-NLP-in-prod.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="Neal Lathia" />

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Neal Lathia</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/research/">Research</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">When is a neural net too big for production?</h1><p class="page-description">Here are some thoughts on the recent discussions around NLP transformer models being too big to put into production, and a dive into how we have shipped them at Monzo using the HuggingFace library.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2019-09-29T00:00:00-05:00" itemprop="datePublished">
        Sep 29, 2019
      </time>
       ‚Ä¢ <span class="read-time" title="Estimated read time">
    
    
      11 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#opinion">opinion</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#monzo">monzo</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="-background">üí¨ Background</h3>
<p>Over the last couple of years, there have been a ton of exciting developments in natural language processing (NLP). In case you haven‚Äôt been working in this area, here‚Äôs the crash course: the development of <a href="http://ruder.io/nlp-imagenet/">deep pre-trained language models</a> has taken the field by storm. In particular, <a href="https://arxiv.org/abs/1706.03762">transformer architectures</a> are everywhere, and were popularised by Google‚Äôs release of the <a href="https://arxiv.org/abs/1810.04805"><strong>B</strong>idirectional <strong>E</strong>ncoder <strong>R</strong>epresentations from <strong>T</strong>ransformers</a> (BERT) model, OpenAI‚Äôs release of the <a href="https://openai.com/blog/better-language-models/">GPT(-2) models</a>, and other similar releases.</p>

<p>Various research teams are continuing to compete to train better language models; if you look at the <a href="https://gluebenchmark.com/leaderboard">General Language Understanding Evaluation (GLUE)</a> benchmark leaderboard, you‚Äôll find a host of other approaches (many of them also named BERT: ALBERT, RoBERTa, etc.). The overarching trend in this research has been to train <strong>bigger</strong> models with <strong>more data</strong> - growing to the extent that researchers <a href="https://arxiv.org/abs/1906.02243">have investigated</a> the costly carbon footprint of training these large networks.</p>

<p>For practicioners, the main selling point of pre-trained language models is that you do not need to start from scratch when developing a new text classifier: you can fine tune a pre-trained model and often get state-of-the-art results with a fraction of the work. But as these models continue to grow in size, folks have started to question how useful they are in practice. For example, this quote in <a href="https://explosion.ai/blog/spacy-pytorch-transformers">a blog post</a> from the explosion.ai team caught my eye (emphasis mine):</p>

<blockquote>
  <p>In a recent talk at Google Berlin, Jacob Devlin described how Google are using his BERT architectures internally. <strong>The models are too large to serve in production, but they can be used to supervise a smaller production model.</strong></p>
</blockquote>

<p>Unfortunately, it looks like this talk <a href="https://twitter.com/honnibal/status/1157592067712966657">was not recorded</a>, and so all of the context around this claim was lost. In light of that, this post gives an overview of how these models <em>can</em> and <em>have been</em> put into production.</p>

<h3 id="-patterns-for-models-in-production">üö¢ Patterns for models in production</h3>
<p>Let‚Äôs begin with a very pragmatic question: <strong>what is ‚Äúproduction?‚Äù</strong></p>

<p>For our purposes, production is the environment where we put software that we have written (and models we have trained) so that it can enable features in a product to work without any manual intervention. By this definition, we exclude any code that we use for analytics or ad-hoc purposes, even though there may be potential applications of NLP in those domains (e.g., sentiment analysis on historical data).</p>

<p>I‚Äôm also assuming that this environment is designed using <a href="https://en.wikipedia.org/wiki/Microservices">microservices</a> ‚Äì which just so happens to be how the <a href="https://monzo.com/blog/2016/09/19/building-a-modern-bank-backend">Monzo backend is designed</a>.</p>

<p>There are three main ways that models can be used in production:</p>

<p><strong>RESTful Services</strong>. This is the first (and sometimes only thing) that comes to mind when folks talk about ‚Äúproduction.‚Äù The idea is to build some kind of microservice with an API which can receive requests, do some work (i.e., get predictions from a model), and return a result. For example, when a customer types a query into the Monzo app‚Äôs help screen, we have a service that receives that request and returns relevant help articles (disclaimer: that has been simplified a bit. We have quite a few services that are involved in this work, but the idea is the same).</p>

<p><strong>Consumer Services</strong>. The second approach is to build a service which listens out for certain events and requests for some work to be done when they happen. For example, when a customer starts chatting with our customer support team, we have a service that is listening for particular events in order to (a) generate embeddings of the chat‚Äôs first turn, and (b) trigger recommendations that are shown to the agent for saved responses that may be relevant to the current query.</p>

<p><strong>Cron Jobs</strong>. These are batches of work that need to be done on a regular basis. For example, we store all of the help articles and agent responses in a content management system - and these are regularly edited and updated with new content. Our search and recommendation services use the <em>embeddings</em> of this content: we therefore have cron jobs that regularly run, encode all of the text and store the embeddings so that they can be used when needed.</p>

<p>In practice, building an end-to-end system is likely to involve more than one of the above. I‚Äôve already mentioned the system which gives our agents response recommendations: this system has a cron job (to encode all of the response text), a consumer service (which decides when recommendations should be triggered), and a RESTful service (which is, effectively, a k-Nearest Neighbour between the encoded customer text and the encoded responses).</p>

<h3 id="Ô∏è-when-is-a-model-too-big">üôÖ‚Äç‚ôÇÔ∏è When is a model too big?</h3>
<p>Now that I‚Äôve described three generic ways that models are shipped, let‚Äôs tackle the main question: when is a model too big? There are two scenarios to consider: (1) a model is too big <em>to ship at all</em>, and (2) a model‚Äôs size is making it inefficient.</p>

<p><strong>Too big to ship at all?</strong> The main question that may prevent shipping a model at all is about reconciling the hardware (where you want to run a model) with the size of the model. In practice, current models‚Äô sizes are not a big problem in cloud-based backend systems, which have a variety of different instance sizes available - the hardware we have in the cloud <em>can</em> ship a model like BERT. It may eat up a ton of memory - but it will <em>work</em>.</p>

<p>This could change if you want to want to ship a model elsewhere (for any other reason). For example, <a href="https://slideslive.com/38917690/multitask-learning-in-the-wilderness">this ICML workshop talk</a> by Andrej Karpathy describes a large multi-task neural net that needs to run in a car, or folks at Google are investigating <a href="https://ai.googleblog.com/2017/04/federated-learning-collaborative.html">federated learning</a> in order to distribute model training across mobile phones. This is part of a broader movement that is pushing machine learning towards ‚Äúedge‚Äù devices, which are generally resource and energy constrained.</p>

<p><strong>Too big to be efficient?</strong> Models are often trained using GPUs, but shipped on non-GPU instances, where inference will be slower. As models get bigger, inference time often continues to grow. There may be a point where this slow down makes it infeasible. This is going to be a very application-specific decision: for example, a chat bot responding within a few seconds may still be ‚Äúfast‚Äù in the customers‚Äô eyes, while if it took a similar time to get search results on Google, something would seem odd. To dig deeper, let‚Äôs reference the three patterns above.</p>

<p>In cron job settings, inference time is usually not such a big deal - predictions can be batched, and need to be completed on a schedule. Performance will become more of an issue as the amount of data grows, and we can then consider parallelising the problem to make it faster.</p>

<p>In the other two patterns, things become even more application specific. Consider, for example, the system I mentioned above that is consuming chat events to decide to push saved response recommendations to our agents. In this case, the time the system needs to generate those recommendations should be (broadly) less than the time that it takes an agent to read through what has been written so far - this use case is measured in the order of multiple seconds; i.e., nearly an eternity for computers.</p>

<p>Finally, we have services that we are experimenting with to try and <a href="https://monzo.com/blog/2018/08/01/data-help">improve the app help screen</a> - some of these are using BERT. In our first experiment, we saw that some of these services were struggling under the load they were receiving - but the first port of call is to <a href="https://github.com/vaquarkhan/vaquarkhan/wiki/Difference-between-scaling-horizontally-and-vertically">scale them horizontally</a> rather than pull the handbrake and not deploy them at all. This means that we are trading off between how many instances we need (or want) to spin up and the performance we want to achieve, much like what happens when these same models are trained on large clusters.</p>

<h3 id="-example-serving-bert-predictions">ü§ó Example: serving BERT predictions</h3>
<p>At Monzo, we have decided for our Python microservices to be as lightweight as possible: they are effectively a nice wrapper around a model‚Äôs <code class="highlighter-rouge">predict()</code> function, and we write the rest in <a href="https://golang.org/">Go</a> - the main language that is used throughout the Monzo backend.</p>

<p>We have built a <a href="https://cookiecutter.readthedocs.io/en/latest/">cookiecutter</a> Python microservice template that uses <a href="https://github.com/huge-success/sanic">Sanic</a>. When one of these services is starting up, it needs to do two, fairly slow, things: (1) find and retrieve the model that it wants to serve (I‚Äôll blog about that problem separately), and (2) load the model (in <code class="highlighter-rouge">eval()</code> mode) and the tokenizer as <code class="highlighter-rouge">global</code> variables in memory.</p>

<p>(Side note: I originally intended to share some code snippets here, but this jekyll theme stubbornly refused to be mobile friendly. So I‚Äôve removed it - but it‚Äôs not far off from the available examples online.)</p>

<p>I did a small test on my own laptop using <a href="https://stackoverflow.com/questions/938733/total-memory-used-by-python-process">this approach</a> which uses <code class="highlighter-rouge">psutil</code> to measure the ‚ÄúResident Set Size‚Äù memory usage (is this the right way? ü§∑‚Äç‚ôÇÔ∏è). Before loading the model, memory usage was about 79 MB: after the call to <code class="highlighter-rouge">load_model()</code>, it shot up to just over 957. A huge jump, yes (and 100s of times bigger than what you would expect in non-machine learning services) - but still well below what decent cloud instances provide.</p>

<p>Once these steps have finished, the service will start serving requests. Each of these services will have an endpoint (or <a href="https://sanic.readthedocs.io/en/latest/sanic/routing.html">Sanic route</a>) to get the model‚Äôs predictions for a given input.</p>

<p>The <code class="highlighter-rouge">async</code> and <code class="highlighter-rouge">await</code> syntax in Sanic routes is the key here: handlers are an <a href="https://docs.python.org/3/library/asyncio-task.html">async co-routine</a>, and all model predictions are run in the <code class="highlighter-rouge">asyncio</code> event loop, rather than as blocking functions. There are many blog posts that describe the details of the Python event loop and the <code class="highlighter-rouge">async / await</code> syntax much better than I ever could; if you‚Äôre interested, I‚Äôd recommend searching for this topic (<a href="https://stackabuse.com/python-async-await-tutorial/">here‚Äôs one</a>).</p>

<p>The <code class="highlighter-rouge">model_predict()</code> runs model predictions with <code class="highlighter-rouge">torch.no_grad()</code>: this ensures that the autograd engine is not used. According to <a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615">this thread</a>, this reduces memory usage and speeds up computation. Naturally, you can‚Äôt then backpropagate (needing to do so while serving is an entirely different type of problem!).</p>

<p>There was one tiny trick that two folks on the team discovered which helped us to make these types of services <em>even faster</em>. They discovered the issue that it seems <a href="https://twitter.com/MarkNeumannnn/status/1067926695338926080">others have also found</a> regarding threading performance and the <code class="highlighter-rouge">OMP_NUM_THREADS</code> and <code class="highlighter-rouge">MKL_NUM_THREADS</code> environment variables; the one difference was that they also had to factor in how all of this plays with Sanic <a href="https://sanic.readthedocs.io/en/latest/sanic/deploying.html#workers">worker threads</a>.</p>

<h3 id="-reflections">üîç Reflections</h3>
<p>The main disclaimer that I‚Äôll add to the above is that we are currently in the stage of development where we‚Äôre iterating on and validating new product features, and not squeezing performance gains out of existing ones. Perhaps, once we reach that stage (where every megabyte of memory, instance we spin up, and microsecond matters), I‚Äôll change my mind about BERT being suitable for production üòä.</p>

<p>So, after writing an entire blog post about how we can (and do) but large models like BERT into production, I‚Äôll close with two thoughts.</p>

<p>First, the research on <a href="https://medium.com/huggingface/distilbert-8cf3380435b5">distilling</a> and <a href="https://arxiv.org/abs/1909.11687">compressing</a> these models into smaller ones that retain similar levels of accuracy is still very valuable. It will unlock our ability to (a) run these models more efficiently, and (b) run them on edge devices at all. Just as training larger models with more data is showing impressive feats of engineering and distributed model training, doing more with less seems to push researchers towards hard, unsolved problems of understanding how neural nets learn at all.</p>

<p>Second: the main (hidden) assumption that I‚Äôve had throughout this whole post is that an <strong>entire</strong> neural net should be shipped as a <strong>single</strong> service. Maybe this doesn‚Äôt have to be the case: a network could be broken up into multiple microservices (e.g., imagine freezing an entire pre-trained network and then shipping multiple different fine-tuned heads into different services). I haven‚Äôt been able to find a lot of blog posts about machine learning in production - if you find (or write!) one, do <a href="https://twitter.com/neal_lathia">send it my way</a>.</p>

<p>Acknowledgements: thanks to <a href="https://stephen.sh/">Stephen Whitworth</a> for feedback on a draft of this post.</p>

  </div><a class="u-url" href="/opinion/monzo/2019/09/29/Large-NLP-in-prod.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p></p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/nlathia" title="nlathia"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/neal_lathia" title="neal_lathia"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
